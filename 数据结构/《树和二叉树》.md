# 树的定义和基本术语 tree

- 树的结点包含一个数据元素以及若干个指向其子树的分支。
- 结点拥有的子树数称为结点的度(degree).
- 度为0的结点称为叶子(leaf)或终端结点。度不为0的结点称为非终端结点或分支结点。
- 除根节点以外，分支结点也称为内部结点。
- 树的度是树内各结点的度的最大值。
- 结点的子树的根称为该结点的孩纸，相应的，该结点称为孩子的双亲(parent).
- 树中结点的最大层次称为树的深度(depth)或者高度。
- 如果将树中结点的各子树看成从左至右是有次序的(即不能互换)，则称该树为有序树，否则称为无序树。
- `森林`(forest)是多颗互不相交的树的集合。

# 二叉树 binary tree

## 性质

1. 在二叉树的第i层上至多有2的(i-1)次方个结点
2. 深度为k的二叉树至多有2的k次方-1个结点。
3. 对任何一颗二叉树，如果其终端结点个数为n0，度为2的结点个数为n2，则n0=n2+1;(推导：n=n0+n1+n2,n=1+2n2+n1)
4. 具有n个结点的完全二叉树的深度为[log2-n]+1

**满二叉树** 一颗深度为k且有2的k次方-1个结点的二叉树称为满二叉树。

**完全二叉树**

可以对满二叉树的结点进行编号，约定编号从根节点起，自上而下，自左至右。 由此可以引出完全二叉树的定义：深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。

## 二叉树的存储结构

1. 顺序存储结构

用一组地址连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。 对于一般二叉树。则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，0表示不存在此结点。

1. 链式存储结构

二叉链表(数据域，左，右指针域)或者三叉链表(多一个指向双亲结点的链域)。

## 遍历二叉树

**构造二叉树**

```
function BinaryNode(value,leftChild,rightChild){
  this.value=value;
  this.lChild=leftChild;
  this.rChild=rightChild;
}
var binaryTree = new BinaryNode("-");
binaryTree.leftChild = new BinaryNode("10");
binaryTree.rightChild = new BinaryNode("7");
function visit(binaryNode){
  if (binaryNode.value) {
    console.log(binaryNode.value);
  }
}
```

**递归先序遍历**

```
preOrderVisit(binaryTree);
function preOrderVisit(binaryTree){
  if (binaryTree) {
    visit(binaryTree);
    preOrderVisit(binaryTree.leftChild);
    preOrderVisit(binaryTree.rightChild);
  }
}
```

**非递归中序遍历**

```
function InorderVisit(binaryTree){
  var stack = [];
  stack.push(binaryTree);
  while (stack.length) {
    while (stack[stack.length-1]) {
      stack.push(stack[stack.length-1].leftChild);
    }
    stack.pop();
    if (stack.length) {
      var tmp = stack.pop();
      visit(tmp);
      stack.push(tmp.rightChild);
    }
  }
}
```

```
function InorderVisit(binaryTree){
  var stack = [],
    tmp = binaryTree;
    while (tmp || stack.length) {
      if (tmp) {
        stack.push(tmp);tmp = tmp.leftChild;
      }else{
        tmp = stack.pop();
        visit(tmp);
        tmp = tmp.rightChild;
      }
    }
}
```

**制造二叉树**

```
var valArr = [0,1,2,"","","",3,4,"",5,"","",6,"","",""];
function createBiTree(){
  while (valArr.length) {
    var binaryNode;
    var tmp = valArr.shift();
    if (tmp !== "") {
      binaryNode = new BinaryNode(tmp);
      binaryNode.leftChild = createBiTree(binaryNode.leftChild);
      binaryNode.rightChild = createBiTree(binaryNode.rightChild);
    }else {
      return  null;
    }
      return binaryNode;
  }
}
var test = createBiTree();
```

## 线索二叉树
